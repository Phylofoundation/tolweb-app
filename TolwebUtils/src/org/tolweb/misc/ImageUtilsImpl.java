/*
 * ImageUtilsImpl.java
 *
 * Created on May 2, 2004, 1:27 PM
 */

package org.tolweb.misc;

import java.awt.Dimension;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;

import org.apache.log4j.Logger;
import org.apache.tapestry.request.IUploadFile;
import org.tolweb.hibernate.Movie;
import org.tolweb.hibernate.Specimen;
import org.tolweb.treegrow.main.Contributor;
import org.tolweb.treegrow.main.FileUtils;
import org.tolweb.treegrow.main.ImageVersion;
import org.tolweb.treegrow.main.NodeImage;
import org.tolweb.treegrow.main.StringUtils;

/**
 *
 * @author  dmandel
 */
public class ImageUtilsImpl implements ImageUtils {
    private static final String EXTENSION = ".png";
    private static final String PREVIEW = "preview";
    private static final String THUMBNAIL_VERSION_NAME = "thumbnail"; 
    private static final int BYTES_PER_KB = 1024;
    private static final double BYTES_PER_MB = 1048576.0;
    private static final int MAX_AUTOGENERATED_HEIGHT = 500;
    private static final int VERSION_STEP_SIZE = 50;
    
    private String movieThumbnailUrl;
    private String soundThumbnailUrl;
    private String documentThumbnailUrl;
    private String imagesDirectory;
    private String thumbsDirectory;
    private String contributorsImagesDirectory;
    private String contributorsUrlPrefix;
    private String specimensImagesDirectory;
    private String specimensUrlPrefix;
    private int defaultThumbnailHeight;
    private String thumbnailUrlPrefix;
    private String urlPrefix;
    private String movieUrlPrefix;
    private String soundUrlPrefix;
    private String documentUrlPrefix;
    private String imagesServerPrefix;
    private Random random;
    private Logger logger;
    private String colorProfilePath;
    private int minImageInfoWindowHeight;
    private int minImageInfoWindowWidth;    
    private String convertCommand;
    private String compositeCommand;
    private String ffmpegCommand;
    private String moviePlayImageLocation;
    
    public ImageUtilsImpl() {
        random = new Random();
        logger = Logger.getLogger(getClass());
    }
    
    /**
     * Used to make sure that all image files stored on the server have unique
     * names
     *
     * @param serverDirectory The path to the directory on the server where the
     *        file should be saved
     * @param clientFilename The name of the image from the client
     * @return The unique server filename
     */
    public String getUniqueServerFilename(String serverDirectory, String clientFilename) {
        String filename = clientFilename;
        String[] pieces = getFilenamePieces(filename);
        String beforeDot = pieces[0];
        String afterDot = pieces[1];
        int count = 1;
        String dotString = (clientFilename.indexOf(".") == -1) ? "" : ".";
        String testFilename = beforeDot + dotString + afterDot;
        while (true) {
            File file = new File(serverDirectory + testFilename);
            if (!file.exists()) {
                filename = testFilename;
                break;
            }
            testFilename = beforeDot + (count++) + dotString + afterDot;
        }
        return serverDirectory + filename;
    }
    
    /**
     * Returns a filename broken into pieces.  The first piece is
     * the filename before the '.' indicating the extension.  The second
     * piece is the extension of the file.
     * @param filename
     * @return A two-item string array containing the filename pieces
     */
    private String[] getFilenamePieces(String filename) {
        filename = stripSlashesFromFilename(filename);
        int dotIndex = filename.lastIndexOf('.');
        String beforeDot;
        String afterDot;
        if (dotIndex != -1) {
            beforeDot = filename.substring(0, dotIndex);
            afterDot = filename.substring(dotIndex + 1);
        } else {
            beforeDot = filename;
            afterDot = "";
        }
        String[] returnArray = {beforeDot, afterDot};
        return returnArray;
    }
    
    public String stripSlashesFromFilename(String filename) {
        char backslash = '\\';
        char forwardslash = '/';
        if (filename.indexOf(backslash) != -1) {
            // It must be our favorite OS, windoze, so find the last occurrence of this
            // 'path' separator and remove it
            filename = filename.substring(filename.lastIndexOf(backslash) + 1);
        } else if (filename.indexOf(forwardslash) != -1) {
            filename = filename.substring(filename.lastIndexOf(forwardslash) + 1);
        }
        return filename;
    }
    
    public String getUniqueServerFilename(String clientFilename) {
        return getUniqueServerFilename(getImagesDirectory(), clientFilename);
    }
    
    public String writeImageFileToDisk(IUploadFile imageFile) {
        return writeImageFileToDisk(imageFile, getImagesDirectory());
    }
    
    public String writeInputStreamToDisk(InputStream stream, String filename) {
    	filename = getCleanedImageFilename(filename);
    	return writeOutStream(stream, filename);
    }
    
    public int getClosestAutogeneratedVersionHeight(int height) {
        int modResult = height % VERSION_STEP_SIZE;
        height -= modResult;
        return height;
    }
       
    /**
     * @return The unique server filename for the image
     */
    public String writeImageFileToDisk(IUploadFile imageFile, String directory) {
        String filename; 
        filename = imageFile.getFileName();
        filename = getCleanedImageFilename(filename, directory);
        filename = writeOutIUploadFile(imageFile, filename);
        return filename;
    }
    
    private String getCleanedImageFilename(String filename) {
        return getCleanedImageFilename(filename, getImagesDirectory());
    }

    private String getCleanedImageFilename(String filename, String directory) {
        filename = StringUtils.cleanStringForFilename(filename);
        // Set up a unique filename for this image on the server
        filename = getUniqueServerFilename(directory, filename);
        return filename;
    }    
    
    private String writeOutIUploadFile(IUploadFile file, String path) {
    	return writeOutStream(file.getStream(), path);
    }
    
    protected String writeOutStream(InputStream stream, String path) {
        InputStream fis = stream; 
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(new File(path));
            byte[] buffer = new byte[1024];  
            while (true) {            
                int length = fis.read(buffer);  
                if (length <  0) {
                    break;
                }
                fos.write(buffer, 0, length);               
            }        
        } catch (IOException ioe) {
            ioe.printStackTrace();
            path = "";
        }  finally {
            if (fis != null) {
                try { fis.close(); } catch (IOException ioe) {}
            }   
            if (fos != null) {
                try { fos.close(); } catch (IOException ioe) {}
            }
        }
        return path;    	
    }
    
    public void setImagesDirectory(String value) {
        imagesDirectory = value;
    }
    
    public String getImagesDirectory() {
        return imagesDirectory;
    }
    
    public void setThumbsDirectory(String value) {
        thumbsDirectory = value;
    }
    
    public String getThumbsDirectory() {
        return thumbsDirectory;
    }
    
    public void setContributorsImagesDirectory(String value) {
        contributorsImagesDirectory = value;
    }
    
    public String getContributorsImagesDirectory() {
        return contributorsImagesDirectory;
    }
    
    public void setContributorsUrlPrefix(String value) {
    	contributorsUrlPrefix = value;
    }
    
    public String getContributorsUrlPrefix() {
    	return contributorsUrlPrefix;
    }
    
	public String getContributorImageUrl(Contributor contr) {
	    return getContributorImageUrl(contr, false);
	}
	
	public String getContributorImageUrl(Contributor contr, boolean includeFullURL) {
	    return returnImageUrl(contr.getImageFilename(), getContributorsUrlPrefix(), includeFullURL);
	}
    private String returnImageUrl(String filename, String urlPrefix, boolean includeFullURL) {
        if (StringUtils.notEmpty(filename)) {
            String prefix = includeFullURL ? getImagesServerPrefix() : "";
            return prefix + urlPrefix + filename;
        } else {
            return null;
        }        
    }
    public void setSpecimensImagesDirectory(String value) {
        specimensImagesDirectory = value;
    }
    public String getSpecimensImagesDirectory() {
        return specimensImagesDirectory;
    }
    public void setSpecimensUrlPrefix(String value) {
        specimensUrlPrefix = value;
    }
    public String getSpecimensUrlPrefix() {
        return specimensUrlPrefix;
    }
    public String getSpecimenImageUrl(Specimen specimen) {
        return returnImageUrl(specimen.getImagePath(), getSpecimensUrlPrefix(), true);
    }
	    
    public int getDefaultThumbnailHeight() {
        return defaultThumbnailHeight;
    }
    
    public void setDefaultThumbnailHeight(int value) {
        defaultThumbnailHeight = value;
    }
    
    public String getServerFileLocation(NodeImage img) {
        return imagesDirectory + img.getLocation();
    }
    
    public String getServerFileLocation(ImageVersion version) {
        return imagesDirectory + version.getFileName();
    }
    
    public String getServerThumbnailFileLocation(NodeImage img, boolean isPreview) {
        String previewString = isPreview ? PREVIEW : "";
        return thumbsDirectory + img.getId() + previewString + EXTENSION;
    }
    
    /**
     * Does the math necessary to get the scaled width for a version with a specified 
     * height.
     * @param img The image to use as a reference point
     * @param height The height of the version to calculate width for
     * @return
     */
    public int calculateWidthForVersionHeight(NodeImage img, int height) {
        Dimension dim = getDimensionsForImage(getServerFileLocation(img));
        int originalHeight = dim.height;
        int originalWidth = dim.width;
        int writeOutHeight = height;
        if (writeOutHeight > originalHeight) {
            writeOutHeight = originalHeight;
        }
        double percentage = (writeOutHeight * 1.0) / (originalHeight * 1.0);
        int newWidth = (int) (originalWidth * percentage);
        return newWidth;
    }
    
    private ImageVersion createMasterImageVersion(NodeImage img) {
        ImageVersion masterVersion = new ImageVersion();
        masterVersion.setImage(img);
        masterVersion.setVersionName("master");
        masterVersion.setContributor(img.getContributor());
        masterVersion.setFileName(img.getLocation());
        masterVersion.setIsMaster(true);
        masterVersion.setIsMaxSize(true);
        int numBytes = getImageFilesize(img);
        masterVersion.setFileSize(getFileSizeStringFromInt(numBytes));
        Dimension dimension = getImageDimensions(img);
        masterVersion.setWidth(Integer.valueOf(dimension.width));
        masterVersion.setHeight(Integer.valueOf(dimension.height));
        return masterVersion;
    }
    
    public List reinitializeAutogeneratedVersions(NodeImage img, List versions) {
        // If this is nothing there, then we need to create a master version for
        // the image
        if (versions.size() == 0) {
            versions.add(createMasterImageVersion(img));
        }
        int maxAutogeneratedVersionHeight = 0;
        int maxHeight = 1;
        for (Iterator iter = versions.iterator(); iter.hasNext();) {
            ImageVersion nextVersion = (ImageVersion) iter.next();
            nextVersion.setImage(img);
            if (nextVersion.getIsGenerated()) {
	            nextVersion.setFileName(null);
	            nextVersion.setFileSize(null);
	            deleteVersionFromFilesystem(nextVersion);
	            int nextVersionHeight = nextVersion.getHeight().intValue();
	            if (nextVersionHeight > maxAutogeneratedVersionHeight) {
	                maxAutogeneratedVersionHeight = nextVersionHeight;
	            }
	            int newWidth = calculateWidthForVersionHeight(img, nextVersion.getHeight().intValue());
	            nextVersion.setWidth(Integer.valueOf(newWidth));
            }
            if (nextVersion.getIsMaxSize()) {
                maxHeight = nextVersion.getHeight().intValue();
            }
        }
        List removedVersions = new ArrayList();
        if (maxAutogeneratedVersionHeight < MAX_AUTOGENERATED_HEIGHT && 
                maxAutogeneratedVersionHeight < maxHeight) {
            // If the max image is right on the border, then don't generate an additional
            // copy of the master at the same size.
            if (maxHeight % VERSION_STEP_SIZE == 0) {
                maxHeight -= VERSION_STEP_SIZE;
            }
            addMissingImageVersions(maxHeight, maxAutogeneratedVersionHeight, versions, img);
        } else if (maxAutogeneratedVersionHeight > maxHeight) {
            removedVersions = removeTooHighImageVersions(maxHeight, versions);
        } 
        Collections.sort(versions);
        // write out the thumbnail since it is definitely needed
        ImageVersion thumbnail = (ImageVersion) versions.get(versions.size() - 1);
        // if it's actually smaller than 100 pixels, it's not the thumb version, so don't write it
        if (thumbnail.getHeight().intValue() >= getDefaultThumbnailHeight()) {
            writeVersionToDisk(thumbnail);
        } else {
            ImageVersion master = thumbnail;
            // In this case the file *is* the thumbnail, so create a new thumbnail version
            // and then copy the same file to the thumbnail
            ImageVersion thumbVersion = new ImageVersion();
            thumbVersion.setVersionName(THUMBNAIL_VERSION_NAME);
            thumbVersion.setFileSize(master.getFileSize());
            thumbVersion.setHeight(master.getHeight());
            thumbVersion.setWidth(master.getWidth());
            thumbVersion.setImage(img);
            thumbVersion.setFileName(getImageVersionFilename(img.getLocation(), getDefaultThumbnailHeight()));
            versions.add(thumbVersion);
            File source = new File(getServerFileLocation(img));
            File dest = new File(getServerFileLocation(thumbVersion));
            if (dest.exists()) {
                dest.delete();
            }
            FileUtils.copyFile(source, dest);
        }
        return removedVersions;
    }
    private String getFilenameNoExtension(NodeImage img) {
    	return getFilenamePieces(img.getLocation())[0];
    }
    /**
     * Removes all versions of the image that are taller than the master.  Returns the
     * list of versions that are removed.
     * @param maxHeight
     * @param versions
     * @return
     */
    List removeTooHighImageVersions(int maxHeight, List versions) {
        List removedVersions = new ArrayList();
        for (Iterator iter = new ArrayList(versions).iterator(); iter.hasNext();) {
            ImageVersion nextVersion = (ImageVersion) iter.next();
            if (nextVersion.getIsGenerated()) {
                if (nextVersion.getHeight().intValue() > maxHeight) {
                    removedVersions.add(nextVersion);
                    versions.remove(nextVersion);
                }
            }
        }
        return removedVersions;
    }
    
    void addMissingImageVersions(int startHeight, int stopHeight, List versions, NodeImage image) {
        if (startHeight > MAX_AUTOGENERATED_HEIGHT) {
            startHeight = MAX_AUTOGENERATED_HEIGHT;
        }
        int modStep = startHeight % VERSION_STEP_SIZE;
        if (modStep != 0) {
            // step down to the next automatic version size
            startHeight -= modStep;
        }
        if (stopHeight < getDefaultThumbnailHeight()) {
            stopHeight = getDefaultThumbnailHeight() - 1;
        }
        for (int currentHeight = startHeight; currentHeight > stopHeight; 
        	currentHeight -= VERSION_STEP_SIZE) {
            ImageVersion version = new ImageVersion();
            version.setHeight(Integer.valueOf(currentHeight));
            int width = calculateWidthForVersionHeight(image, currentHeight);
            version.setWidth(Integer.valueOf(width));
            version.setImage(image);
            if (currentHeight > getDefaultThumbnailHeight()) {
                version.setVersionName(currentHeight + "px high");
            } else {
                version.setVersionName(THUMBNAIL_VERSION_NAME);
            }
            versions.add(version);
        }
    }    
    
    public String getUrlForVersion(ImageVersion version) {
        return getImagesServerPrefix() + getUrlPrefix() + version.getFileName();
    }
    
    public String getFileSizeStringFromInt(int numBytes) {
        if (numBytes < BYTES_PER_MB) {
            int numKbytes = numBytes / BYTES_PER_KB;
            return numKbytes + "K";
        } else {
            double numMbytes = numBytes / BYTES_PER_MB;
            NumberFormat oneDecimalFormatter = NumberFormat.getInstance();
            oneDecimalFormatter.setMinimumFractionDigits(1);
            oneDecimalFormatter.setMaximumFractionDigits(1);
            String megsString = oneDecimalFormatter.format(numMbytes);
            return megsString + "M";
        }
    }
    
    public String getImageVersionFilename(String originalFilename, int height) {
        String[] pieces = getFilenamePieces(originalFilename);
        String newFirstPart = pieces[0] + "." + height + "a";
        return newFirstPart + "." + pieces[1];
    }
    
    public void writeVersionToDisk(ImageVersion version) {
        String newFilename = getImageVersionFilename(version.getImage().getLocation(), version.getHeight().intValue());
        String fullPath = getImagesDirectory() + newFilename;
        String originalLoc = getServerFileLocation(version.getImage());
        int filesize = resizeImageFile(originalLoc, fullPath, version.getWidth().intValue(), version.getHeight().intValue());
        version.setFileName(newFilename);
        String filesizeString = getFileSizeStringFromInt(filesize);
        version.setFileSize(filesizeString);
        if (version.getVersionName().equals(THUMBNAIL_VERSION_NAME)) {
            // temporarily need to copy the thumbnail back over to the old thumbnails directory
            File currentThumb = new File(getImagesDirectory() + newFilename);
            File destinationThumb = new File(getThumbsDirectory() + version.getImage().getId() + ".png");
            if (currentThumb.exists() && destinationThumb.exists()) {
                destinationThumb.delete();
            }
            if (currentThumb.exists()) {
                FileUtils.copyFile(currentThumb, destinationThumb);
            }
        }
    }
    
    public String getFlashVideoFilename(Movie movie) {
    	return getFilenameNoExtension(movie) + ".flv";
    }
    public String getFlashVideoUrl(Movie movie) {
    	return getMovieUrlPrefix() + getFlashVideoFilename(movie);
    }
    public List writeMovieFilesToDisk(Movie movie) {
    	String movieLocation = getServerFileLocation(movie);
    	String filenameNoExtension = getFilenameNoExtension(movie);
    	String tmpDir = System.getProperty("java.io.tmpdir");
    	tmpDir += "/";
    	String firstFrameFile = tmpDir + filenameNoExtension + "1.jpg";
    	// have the part of the filename before the extension, add a '1' and a .jpg extension
    	String commandLine = getFfmpegCommand() + " -i " + movieLocation + " -vframes 1 " + tmpDir + filenameNoExtension + "%d.jpg";
    	String flashVideoFilenameWPath = getImagesDirectory() + getFlashVideoFilename(movie);
    	try {
			// basic idea -- try grabbing the first frame of the movie using ffmpeg
			// if this works, store the width and height on the master version, create
			// a special thumbnail w/ the movie icon in it then convert the movie
			// file to flash video and mark the movie as being flash video compatible    		
			long fileLength = shellOutAndCreateFile(firstFrameFile, commandLine, true);
			if (fileLength > 0) {
				// first frame was grabbed, so convert the flash video
				String flashConvertCmdLine = getFfmpegCommand() + " -i " + movieLocation + " -b 1024k -ar 44100 " + flashVideoFilenameWPath;
				shellOutAndCreateFile(flashVideoFilenameWPath, flashConvertCmdLine, true);
				List<ImageVersion> returnList = new ArrayList<ImageVersion>();
				ImageVersion masterVersion = new ImageVersion();
				Dimension masterDimension = getDimensionsForImage(firstFrameFile);
				masterVersion.setVersionName("master");
				masterVersion.setHeight(masterDimension.height);
				masterVersion.setWidth(masterDimension.width);
				masterVersion.setContributor(movie.getContributor());
				masterVersion.setImage(movie);
				masterVersion.setIsMaster(true);
				masterVersion.setIsMaxSize(true);
				returnList.add(masterVersion);
				// add the 'movie' to the filename to avoid collision with similarly named image thumbnails
				String thumbfileName = getMovieThumbnailFilename(movie);
				String thumbfile = getImagesDirectory() + thumbfileName;
				// go ahead and create the thumbnail
				String thumbnailCommandLine = getConvertCommand() + " -resize x" + getDefaultThumbnailHeight() + " " + firstFrameFile + " " + thumbfile;
				shellOutAndCreateFile(thumbfile, thumbnailCommandLine, true);
				// then call composite on itself to embed the play button
				String compositeCommandLine = getCompositeCommand() + " -gravity Center " + getMoviePlayImageLocation() + " " + thumbfile + " " + thumbfile;
				shellOutAndCreateFile(thumbfile, compositeCommandLine, false);
				ImageVersion thumbnailVersion = new ImageVersion();
				thumbnailVersion.setVersionName("thumbnail");
				thumbnailVersion.setHeight(getDefaultThumbnailHeight());
				thumbnailVersion.setWidth(getDefaultThumbnailHeight());
				thumbnailVersion.setContributor(movie.getContributor());
				thumbnailVersion.setImage(movie);
				thumbnailVersion.setFileName(thumbfileName);
				returnList.add(thumbnailVersion);
				return returnList;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
    	return null;
    }
    private String getMovieThumbnailFilename(Movie movie) {
    	String movieLocation = getServerFileLocation(movie);
    	String filenameNoExtension = getFilenamePieces(movieLocation)[0];
    	return filenameNoExtension + "movie.100a.jpg";
    }

    private boolean getVersionExistsOnDisk(ImageVersion version) {
        String newFilename = getImageVersionFilename(version.getImage().getLocation(), version.getHeight().intValue());
        String fullPath = getImagesDirectory() + newFilename;
        return new File(fullPath).exists();
    }

	private long shellOutAndCreateFile(String destinationLocation, String commandLine, boolean deleteIfExists) throws IOException, InterruptedException {
        File newFile = new File(destinationLocation);
        if (deleteIfExists && newFile.exists()) {
            newFile.delete();
        }		
		Process process = Runtime.getRuntime().exec(commandLine);
		StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), "ERROR");
		errorGobbler.start();
		StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), "OUTPUT");
		outputGobbler.start();
		process.waitFor();
		long length = newFile.length();
		return length;
	}    
    private int resizeImageFile(String originalFileLocation, String destinationLocation, int width, int height) {
        try {
            int quality;
            if (height > 250) {
                quality = 85;
            } else if (height <= 250 && height > 150) {
                quality = 90;
            } else {
                quality = 95;
            }

            String commandLine = getConvertCommand() + " -resize x" + height + " -unsharp 0.5x1.0+0.5 -profile " + getColorProfilePath() + " -quality " + quality + " " + originalFileLocation + " " + destinationLocation;
            long length = shellOutAndCreateFile(destinationLocation, commandLine, true);
            if (length == 0) {
                throw new RuntimeException("thumbnailing failed. command line was: " + commandLine);
            }
            return (int) length;
        } catch (Exception e) {
            logger.info("couldn't write thumbnail: ", e);
            e.printStackTrace();
            return -1;
        }        
    }
       
    public void copyPreviewThumbnailToActualThumbnail(NodeImage img) {
        copyOneThumbToAnother(img, true);
    }
    
    public void copyActualThumbailToPreviewThumbnail(NodeImage img) {
        copyOneThumbToAnother(img, false);
    }
    
    private void copyOneThumbToAnother(NodeImage img, boolean previewToActual) {
        File fromThumb = new File(getServerThumbnailFileLocation(img, previewToActual));
        File toThumb = new File(getServerThumbnailFileLocation(img, !previewToActual));
        if (toThumb.exists()) {
            toThumb.delete();
        }
        FileUtils.copyFile(fromThumb, toThumb);        
    }
    
    public String getImageThumbnailUrl(NodeImage img, boolean isPreview) {
        Class movieClass = null;
        Class soundClass = null;
        Class documentClass = null;
        try {
	        soundClass = Class.forName("org.tolweb.hibernate.Sound");
	        movieClass = Class.forName("org.tolweb.hibernate.Movie");
	        documentClass = Class.forName("org.tolweb.hibernate.Document");
        } catch (Exception e) {
            e.printStackTrace();
        }
        if (movieClass.isInstance(img)) {
        	Movie movie = (Movie) img;
        	if (!movie.getUseFlashVideo()) {
        		return getMovieThumbnailUrl();
        	} else {
        		return getImagesServerPrefix() + getMovieUrlPrefix() + getMovieThumbnailFilename(movie);
        	}
        } else if (soundClass.isInstance(img)) {
            return getSoundThumbnailUrl();
        } else if (documentClass.isInstance(img)) {
            return getDocumentThumbnailUrl();
        } else {
	        // Used to trick browser caches into thinking it's a different
	        // file so they don't use the cached version
	        String cacheSpoofString = isPreview ? ("?x=" + random.nextInt()) : "";
	        String filename = getImageVersionFilename(img.getLocation(), getDefaultThumbnailHeight());
	        return getImagesServerPrefix() + getUrlPrefix() + filename + cacheSpoofString;
        }
    }
    
    public String getImageUrl(NodeImage img) {
        return getMediaUrl(img.getMediaType(), img.getLocation());
    }
    
    public String getMediaUrl(int mediaType, String mediaLoc) {
        String baseUrl = "";
        if (mediaType == NodeImage.IMAGE) {
            baseUrl = getUrlPrefix();
        } else if (mediaType == NodeImage.DOCUMENT) {
            baseUrl = getDocumentUrlPrefix();
        } else if (mediaType == NodeImage.SOUND) {
            baseUrl = getSoundUrlPrefix();
        } else if (mediaType == NodeImage.MOVIE) {
            baseUrl = getMovieUrlPrefix();
        }
        return baseUrl + mediaLoc;
    }
    
    public String getVersionUrl(ImageVersion version) {
        boolean isGenerated = version.getIsGenerated();
        boolean exists = getVersionExistsOnDisk(version);
        boolean hasFilename = StringUtils.notEmpty(version.getFileName());
        if (isGenerated && (!exists || !hasFilename)) {
            writeVersionToDisk(version);
        }
        String hostString = StringUtils.notEmpty(getImagesServerPrefix()) ?  
        		getImagesServerPrefix() : "";
        return hostString + getUrlPrefix() + version.getFileName();
    }
    
    public String getThumbnailUrlPrefix() {
        return thumbnailUrlPrefix;
    }
    
    public String getMovieThumbnailUrl() {
        return movieThumbnailUrl;
    }
    
    public void setMovieThumbnailUrl(String value) {
        movieThumbnailUrl = value;
    }
    
    public void setSoundThumbnailUrl(String value) {
        soundThumbnailUrl = value;
    }
    public String getSoundThumbnailUrl() {
        return soundThumbnailUrl;
    }
    
    /**
     * @return Returns the documentThumbnailUrl.
     */
    public String getDocumentThumbnailUrl() {
        return documentThumbnailUrl;
    }
    /**
     * @param documentThumbnailUrl The documentThumbnailUrl to set.
     */
    public void setDocumentThumbnailUrl(String documentThumbnailUrl) {
        this.documentThumbnailUrl = documentThumbnailUrl;
    }
    public String getUrlPrefix() {
        return urlPrefix;
    }
    
    public void setThumbnailUrlPrefix(String thumbUrlPrefix) {
        thumbnailUrlPrefix = thumbUrlPrefix;
    }
    
    public void setUrlPrefix(String u) {
        urlPrefix = u;
    }
    
    public void setImagesServerPrefix(String value) {
        imagesServerPrefix = value;
    }
    
    public String getImagesServerPrefix() {
        return imagesServerPrefix;
    }
    
    public Dimension getImageDimensions(NodeImage img) {
        return getDimensionsForImage(getServerFileLocation(img));
    }

    /* (non-Javadoc)
     * @see org.tolweb.misc.ImageUtils#getVersionDimensions(org.tolweb.treegrow.main.ImageVersion)
     */
    public Dimension getVersionDimensions(ImageVersion version) {
        return getDimensionsForImage(getServerFileLocation(version));
    }
    
    private Dimension getDimensionsForImage(String serverImagePath) {
        ImageInfo info = new ImageInfo();
        FileInputStream stream = null;
    	try {
    		stream = new FileInputStream(serverImagePath);
            info.setInput(stream);
            if (info.check()) {
                return new Dimension(info.getWidth(), info.getHeight());
            } else {
                throw new RuntimeException("serverImagePath that's broken is: " + serverImagePath);
            }
        } catch (Exception e) {
            return new Dimension(100, 100);
        } finally {
        	if (stream != null) {
        		try {
					stream.close();
				} catch (IOException e) {
				}
        	}
        }
    }
    
    public String getJavascriptViewImageWindowFeatures(int width, int height) {
        return "resizable,height=" + height + ",width=" + width + ",scrollbars=yes";
    }

    /* (non-Javadoc)
     * @see org.tolweb.misc.ImageUtils#getVersionFilesize(org.tolweb.treegrow.main.ImageVersion)
     */
    public int getVersionFilesize(ImageVersion version) {
        try {
            File file = new File(getServerFileLocation(version));
            return (int) file.length();
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }
    
    public int getImageFilesize(NodeImage image) {
        try {
            File file = new File(getServerFileLocation(image));
            return (int) file.length();
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }
    
    public void deleteVersionFromFilesystem(ImageVersion version) {
        if (StringUtils.notEmpty(version.getFileName())) {
            File file = new File(getServerFileLocation(version));
            if (file.exists()) {
                file.delete();
            }
        }
    }
    
    public Map createImagesFromZip(IUploadFile file) {
        Hashtable oldToNewFilenames = new Hashtable();
        try {
            String tmpDir = System.getProperty("java.io.tmpdir");
            File dir = new File(tmpDir);
            String filename = dir + "/" + file.getFileName();
            writeOutIUploadFile(file, filename);
            ZipFile zf = new ZipFile(filename);
            Enumeration list = zf.entries();
            while (list.hasMoreElements()) {
                ZipEntry ze = (ZipEntry)list.nextElement();
                if (ze.isDirectory()) {
                    continue;
                }
                try {
                    dumpZipEntry(zf, ze, oldToNewFilenames);
                } catch (IOException e) {
                    e.printStackTrace();
                }                    
            }
            // Clean up the zip file once the individual entries have been written out.
            File zip = new File(filename);
            if (zip.exists()) {
                zip.delete();
            }
        } catch (ZipException e1) {
            e1.printStackTrace();
        } catch (IOException e2) {
            e2.printStackTrace();
        }
        return oldToNewFilenames;
    }
    
    private void dumpZipEntry(ZipFile zf, ZipEntry ze, Map filenamesMap) throws IOException {
        InputStream istr = zf.getInputStream(ze);
        String filename = ze.getName();
        filename = StringUtils.cleanStringForFilename(filename);
        String originalFilename = stripSlashesFromFilename(filename);
        // Set up a unique filename for this image on the server
        filename = getUniqueServerFilename(getImagesDirectory(), filename);
        String newfilenameNoSlashes = stripSlashesFromFilename(filename);
        filenamesMap.put(originalFilename, newfilenameNoSlashes);
        BufferedInputStream bis = null;
        FileOutputStream fos = null;
        try {
        	bis = new BufferedInputStream(istr);        	
	        fos = new FileOutputStream(filename);
	        int sz = (int)ze.getSize();
	        final int N = 1024;
	        byte buf[] = new byte[N];
	        int ln = 0;
	        while (sz > 0 &&  // workaround for bug
	          (ln = bis.read(buf, 0, Math.min(N, sz))) != -1) {
	            fos.write(buf, 0, ln);
	            sz -= ln;
	         }
        } finally {
        	if (bis != null) {
        		bis.close();
        	}
        	if (fos != null) {
        		fos.flush();
        		fos.close();
        	}
        }
        
    }
    

	public Dimension getImageInfoWindowSize(int imageWidth, int imageHeight) {
		return new Dimension(Math.max(imageWidth, getMinImageInfoWindowWidth()), Math.max(imageHeight, getMinImageInfoWindowHeight()));
	}    
    
    /**
     * @return Returns the colorProfilePath.
     */
    public String getColorProfilePath() {
        return colorProfilePath;
    }
    /**
     * @param colorProfilePath The colorProfilePath to set.
     */
    public void setColorProfilePath(String colorProfilePath) {
        this.colorProfilePath = colorProfilePath;
    }
    /**
     * @return Returns the documentUrlPrefix.
     */
    public String getDocumentUrlPrefix() {
        return documentUrlPrefix;
    }
    /**
     * @param documentUrlPrefix The documentUrlPrefix to set.
     */
    public void setDocumentUrlPrefix(String documentUrlPrefix) {
        this.documentUrlPrefix = documentUrlPrefix;
    }
    /**
     * @return Returns the movieUrlPrefix.
     */
    public String getMovieUrlPrefix() {
        return movieUrlPrefix;
    }
    /**
     * @param movieUrlPrefix The movieUrlPrefix to set.
     */
    public void setMovieUrlPrefix(String movieUrlPrefix) {
        this.movieUrlPrefix = movieUrlPrefix;
    }
    /**
     * @return Returns the soundUrlPrefix.
     */
    public String getSoundUrlPrefix() {
        return soundUrlPrefix;
    }
    /**
     * @param soundUrlPrefix The soundUrlPrefix to set.
     */
    public void setSoundUrlPrefix(String soundUrlPrefix) {
        this.soundUrlPrefix = soundUrlPrefix;
    }

	public int getMinImageInfoWindowHeight() {
		return minImageInfoWindowHeight;
	}

	public void setMinImageInfoWindowHeight(int minImageInfoWindowHeight) {
		this.minImageInfoWindowHeight = minImageInfoWindowHeight;
	}

	public int getMinImageInfoWindowWidth() {
		return minImageInfoWindowWidth;
	}

	public void setMinImageInfoWindowWidth(int minImageInfoWindowWidth) {
		this.minImageInfoWindowWidth = minImageInfoWindowWidth;
	}

	public String getCompositeCommand() {
		return compositeCommand;
	}

	public void setCompositeCommand(String compositeCommand) {
		this.compositeCommand = compositeCommand;
	}

	public String getConvertCommand() {
		return convertCommand;
	}

	public void setConvertCommand(String convertCommand) {
		this.convertCommand = convertCommand;
	}

	public String getFfmpegCommand() {
		return ffmpegCommand;
	}

	public void setFfmpegCommand(String ffmpegCommand) {
		this.ffmpegCommand = ffmpegCommand;
	}

	public String getMoviePlayImageLocation() {
		return moviePlayImageLocation;
	}

	public void setMoviePlayImageLocation(String playImage) {
		this.moviePlayImageLocation = playImage;
	}
	
	public static void main(String[] args) {
		System.out.println("temp dir is: " + System.getProperty("java.io.tmpdir"));
	}
}
